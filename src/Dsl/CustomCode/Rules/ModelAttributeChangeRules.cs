using System.CodeDom.Compiler;
using System.Linq;
using System.Windows.Forms;
using Microsoft.VisualStudio.Modeling;

namespace Sawczyn.EFDesigner.EFModel.CustomCode.Rules
{
   [RuleOn(typeof(ModelAttribute), FireTime = TimeToFire.TopLevelCommit)]
   public class ModelAttributeChangeRules : ChangeRule
   {
      public static readonly string[] ValidIdentityAttributeTypes =
      {
         "Int16",
         "Int32",
         "Int64",
         "Byte",
         "Guid"
      };

      public override void ElementPropertyChanged(ElementPropertyChangedEventArgs e)
      {
         base.ElementPropertyChanged(e);

         ModelAttribute element = (ModelAttribute)e.ModelElement;
         ModelClass modelClass = element.ModelClass;

         Store store = element.Store;
         Transaction current = store.TransactionManager.CurrentTransaction;

         if (current.IsSerializing)
            return;

         string errorMessage = null;

         switch (e.DomainProperty.Name)
         {
            case "Indexed":
               if (element.IsIdentity)
                  element.Indexed = true;

               if (element.IsConcurrencyToken)
                  element.Indexed = false;

               if (element.Indexed)
                  element.Persistent = true;

               break;

            case "Type":
               if (element.IsIdentity)
                  if (!ValidIdentityAttributeTypes.Contains(element.Type))
                  {
                     errorMessage = $"Properties of type {element.Type} can't be used as identity properties.";
                  }
                  else
                  {
                     element.Required = true;
                     element.Persistent = true;
                  }

               if (element.Type != "String")
               {
                  element.MaxLength = 0;
                  element.StringType = HTML5Type.None;
               }
               else
               {
                  if (!element.HasValidDefault())
                     element.InitialValue = null;
               }

               break;

            case "MaxLength":
               if (element.Type != "String")
                  element.MaxLength = 0;

               if (element.MaxLength < 0)
                  errorMessage = "MaxLength must be zero or a positive number";

               break;

            case "IdentityType":
               if (element.IsIdentity)
               {
                  if (element.IdentityType == IdentityType.None)
                     errorMessage = "Identity properties must have an identity type defined";
                  else 
                     element.AutoProperty = true;
               }
               else if (!element.IsIdentity)
                  element.IdentityType = IdentityType.None;

               break;

            case "ReadOnly":
               if (!element.Persistent || element.SetterVisibility != SetterAccessModifier.Public)
                  element.ReadOnly = false;
               break;

            case "Virtual":
               if (element.Persistent)
                  element.Virtual = false;
               break;

            case "IsIdentity":
               if (element.IsIdentity)
                  if (!ValidIdentityAttributeTypes.Contains(element.Type))
                  {
                     errorMessage = $"Properties of type {element.Type} can't be used as identity properties.";
                  }
                  else
                  {
                     element.IsConcurrencyToken = false;
                     element.Indexed = true;
                     element.IndexedUnique = true;
                     element.Persistent = true;
                     element.Required = true;

                     if (element.IdentityType == IdentityType.None)
                        element.IdentityType = IdentityType.AutoGenerated;
                  }
               else
                  element.IdentityType = IdentityType.None;

               break;

            case "IsConcurrencyToken":
               if (element.IsConcurrencyToken)
               {
                  element.IsIdentity = false;
                  element.Persistent = true;
                  element.Required = true;
               }

               break;

            case "Required":
               if (!element.Required)
                  if (element.IsIdentity || element.IsConcurrencyToken)
                     element.Required = true;

               break;

            case "Persistent":
               if (!element.Persistent)
               {
                  element.IsIdentity = false;
                  element.Indexed = false;
                  element.IndexedUnique = false;
                  element.IdentityType = IdentityType.None;
                  element.IsConcurrencyToken = false;
                  element.Virtual = false;
               }

               break;

            case "Name":
               string s = (string)e.NewValue;

               if (string.IsNullOrEmpty(s))
                  errorMessage = "Name must be a valid .NET identifier";
               else
               {
                  ModelAttribute.ParseResult fragment = ModelAttribute.Parse(element.ModelClass.ModelRoot, s);

                  if (!string.IsNullOrEmpty(fragment.ErrorMessage))
                     errorMessage = fragment.ErrorMessage;
                  else
                  {
                     if (string.IsNullOrEmpty(fragment.Name) || !CodeGenerator.IsValidLanguageIndependentIdentifier(fragment.Name))
                        errorMessage = "Name must be a valid .NET identifier";
                     else if (modelClass.AllAttributes.Except(new[] {element}).Any(x => x.Name == fragment.Name))
                        errorMessage = "Property name already in use";
                     else if (modelClass.AllNavigationProperties().Any(p => p.PropertyName == fragment.Name))
                        errorMessage = "Property name already in use";
                     else
                     {
                        element.Name = fragment.Name;
                        if (fragment.Type != null) element.Type = fragment.Type;
                        if (fragment.Required != null) element.Required = fragment.Required.Value;
                        if (fragment.MaxLength != null) element.MaxLength = fragment.MaxLength.Value;
                        if (fragment.InitialValue != null) element.InitialValue = fragment.InitialValue;
                        if (fragment.IsIdentity) element.IsIdentity = true; // don't reset to false if not entered as part of name
                     }
                  }
               }

               break;

            case "InitialValue":
               if (!element.HasValidDefault())
                  errorMessage = $"{element.InitialValue} isn't a valid value for {element.Type}";

               break;
         }

         if (errorMessage != null)
         {
            current.Rollback();
            MessageBox.Show(errorMessage);
         }
      }
   }
}
